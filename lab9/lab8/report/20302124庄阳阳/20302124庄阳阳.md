**操作系统原理 实验八**

## 个人信息

【院系】计算机学院

【专业】计算机科学与技术

【学号】20302124

【姓名】庄阳阳

## 实验题目

从内核态到用户态

## 实验目的

1. 理解区分内核态和用户态的必要性。
2. 编写一个系统调用，并分析系统调用前后栈的变化。
3. 掌握用户态与内核态之间切换的过程。
4. 掌握进程创建的过程。
5. 分析fork/exit/wait指令执行过程。
6. 学习如何通过分页机制隔离进程间的地址空间。

## 实验要求

1. 编写一个系统调用。
2. 掌握用户态与内核态之间切换的过程。
3. 实现fork/exit/wait指令。
4. 实现进程之间的隔离。
5. 撰写实验报告。

## 实验方案



## Assignment 1 系统调用

#### 存储方式--寄存器 VS 栈

栈的问题：用户程序使用系统调用时会进行特权级转移。如果我们使用栈来传递参数，在我们调用系统调用的时候，系统调用的参数（即`asm_system_call`的参数）就会被保存在用户程序的栈中，也就是低特权级的栈中。系统调用发生后，我们从低特权级转移到高特权级，此时CPU会从TSS中加载高特权级的栈地址到esp寄存中。而C语言的代码在编译后会使用esp和ebp来访问栈的参数，但是前面保存参数的栈和现在期望取出函数参数而访问的栈并不是同一个栈，因此CPU无法在栈中找到函数的参数。为了解决这个问题，我们通过寄存器来传递系统调用的参数。

`asm_system_call`是通过汇编来实现的，如下所示。

```asm
asm_system_call:
    push ebp
    mov ebp, esp

    push ebx
    push ecx
    push edx
    push esi
    push edi  ; 系统调用的五个参数
    push ds
    push es
    push fs
    push gs

    mov eax, [ebp + 2 * 4]
    mov ebx, [ebp + 3 * 4]
    mov ecx, [ebp + 4 * 4]
    mov edx, [ebp + 5 * 4]
    mov esi, [ebp + 6 * 4]
    mov edi, [ebp + 7 * 4]

    int 0x80 ;使用指令int 0x80调用0x80中断。0x80中断处理函数会根据保存在eax的系统调用号来调用不同的函数。

    pop gs
    pop fs
    pop es
    pop ds
    pop edi
    pop esi
    pop edx
    pop ecx
    pop ebx
    pop ebp

    ret
```



#### 系统调用实现

创建一个管理系统调用的类`SystemService`，如下所示，代码放在`syscall.h`中。

```cpp
#ifndef SYSCALL_H
#define SYSCALL_H

#include "os_constant.h"

class SystemService
{
public:
    SystemService();
    void initialize();
    // 设置系统调用，index=系统调用号，function=处理第index个系统调用函数的地址
    bool setSystemCall(int index, int function);
};

// 第0个系统调用
int syscall_0(int first, int second, int third, int forth, int fifth);

#endif
```



在用户程序使用系统调用之前，我们首先要对系统调用表进行初始化。其次，由于我们的系统调用是通过0x80号中断来完成的，我们加入0x80中断对应的中断描述符。

```cpp
void SystemService::initialize()
{
    memset((char *)system_call_table, 0, sizeof(int) * MAX_SYSTEM_CALL);
    // 代码段的选择子默认是DPL=0的平坦模式代码段选择子，
    // 但中断描述符的DPL=3，否则用户态程序无法使用该中断描述符
    interruptManager.setInterruptDescriptor(0x80, (uint32)asm_system_call_handler, 3);
}
```



我们现在回到`SystemService`中，加入设置系统调用的函数。

```cpp
bool SystemService::setSystemCall(int index, int function)
{
    system_call_table[index] = function;
    return true;
}
```

其中，`function`是第`index`个系统调用的处理函数的地址。

最后设置系统调用号为0的系统调用处理函数。



#### 初始化TSS和用户段描述符

我们首先向`ProgramManager`中加入存储3个代码段、数据段和栈段描述符的变量。

```cpp
class ProgramManager
{
public:
    List allPrograms;        // 所有状态的线程/进程的队列
    List readyPrograms;      // 处于ready(就绪态)的线程/进程的队列
    PCB *running;            // 当前执行的线程
    int USER_CODE_SELECTOR;  // 用户代码段选择子
    int USER_DATA_SELECTOR;  // 用户数据段选择子
    int USER_STACK_SELECTOR; // 用户栈段选择子
    ...
}
```

由于进程的运行环境需要用到TSS、特权级3下的平坦模式代码段和数据段描述符，我们现在来初始化这些内容，如下所示。

```cpp
void ProgramManager::initialize()
{
    allPrograms.initialize();
    readyPrograms.initialize();
    running = nullptr;

    for (int i = 0; i < MAX_PROGRAM_AMOUNT; ++i)
    {
        PCB_SET_STATUS[i] = false;
    }

    // 初始化用户代码段、数据段和栈段
    int selector;

    selector = asm_add_global_descriptor(USER_CODE_LOW, USER_CODE_HIGH);
    // USER_CODE_LOW  0x0000ffff    USER_CODE_HIGH 0x00cff800
    USER_CODE_SELECTOR = (selector << 3) | 0x3;

    selector = asm_add_global_descriptor(USER_DATA_LOW, USER_DATA_HIGH);
    USER_DATA_SELECTOR = (selector << 3) | 0x3;
    // USER_DATA_LOW  0x0000ffff    USER_DATA_HIGH 0x00cff200

    selector = asm_add_global_descriptor(USER_STACK_LOW, USER_STACK_HIGH);
    USER_STACK_SELECTOR = (selector << 3) | 0x3;
	// USER_STACK_LOW  0x00000000   USER_STACK_HIGH 0x0040f600
    initializeTSS();
}
```

将用户代码段描述符，数据段描述符和栈段描述符送入GDT（第三个LAB曾经有具体讲过）。这3个描述符和之前的描述符不同之处在于DPL。之前的描述符的DPL为0，而这几个描述符的DPL为3。



接下创建一个TSS的结构体。

```cpp
#ifndef TSS_H
#define TSS_H

struct TSS
{
public:
    int backlink;
    int esp0;
    int ss0;
    int esp1;
    int ss1;
    int esp2;
    int ss2;
    int cr3;
    int eip;
    int eflags;
    int eax;
    int ecx;
    int edx;
    int ebx;
    int esp;
    int ebp;
    int esi;
    int edi;
    int es;
    int cs;
    int ss;
    int ds;
    int fs;
    int gs;
    int ldt;
    int trace;
    int ioMap;
};
#endif
```

注意，TSS的内容必须如此安排，因为CPU规定了TSS中的内容。如果不做上述安排，当CPU加载TSS时就会加载到错误的数据。



TSS的初始化如下。

```cpp
void ProgramManager::initializeTSS()
{

    int size = sizeof(TSS);
    int address = (int)&tss; // 地址

    memset((char *)address, 0, size); // 赋0初始化
  
    tss.ss0 = STACK_SELECTOR; // 内核态堆栈段选择子

    int low, high, limit;

    limit = size - 1; // 段界限长度
    low = (address << 16) | (limit & 0xff);
    // DPL = 0
    high = (address & 0xff000000) | ((address & 0x00ff0000) >> 16) | ((limit & 0xff00) << 16) | 0x00008900;

    int selector = asm_add_global_descriptor(low, high); //将TSS送入GDT
    // RPL = 0
    asm_ltr(selector << 3);
    tss.ioMap = address + size;
}
```

由于TSS的作用仅限于提供0特权级下的栈指针和栈段选择子，因此我们关心`TSS::ss0`和`TSS::esp0`。但在这里我们只对`TSS::ss0`进行复制，`TSS::esp0`会在进程切换时更新。

其中，`STACK_SELECTOR`是特权级0下的栈段选择子，也就是我们在bootloader中放入了SS的选择子。



#### 进程的创建

进程和线程的区别在于进程有自己的虚拟地址空间和相应的分页机制。

进程的创建分为3步。

- **创建进程的PCB**。
- **初始化进程的页目录表**。
- **初始化进程的虚拟地址池**。

大部分与线程创建是类似的，就不再赘述。

不同的地方：

需要定义一个类`ProgramStartStack`来表示启动进程之前栈放入的内容。

```cpp
#ifndef PROCESS_H
#define PROCESS_H

struct ProcessStartStack
{
    int edi;
    int esi;
    int ebp;
    int esp_dummy;
    int ebx;
    int edx;
    int ecx;
    int eax;
    
    int gs;
    int fs;
    int es;
    int ds;

    int eip;
    int cs;
    int eflags;
    int esp;
    int ss;
};

#endif
```



还需要中断返回来启动进程：

```asm
; void asm_start_process(int stack);
asm_start_process:
    ;jmp $
    mov eax, dword[esp+4]
    mov esp, eax
    popad
    pop gs;
    pop fs;
    pop es;
    pop ds;

    iret
```

我们将`ProcessStartStack`的起始地址送入了esp，然后通过一系列的pop指令和iret语句更新寄存器，最后中断返回后，特权级3的选择子被放入到段寄存器中，代码跳转到进程的起始处执行。

用户进程和内核线程使用的是不同的代码段、数据段和栈段选择子。我们之前在实现基于时钟中断的调度时，并没有对`ds,fs,es,gs`寄存器进行保护和恢复。所以，当我们在内核线程和用户进程之前切换的时候，上面提到的4个寄存器可能没有被切换到用户进程或内核线程使用的`ds,fs,es,gs`。但对于`cs,ss`，CPU会自动保护和恢复。为了解决这个问题，我们修改`asm_time_interrupt_handler`，加入保护和恢复`ds,fs,es,gs`的代码。

```assembly
asm_time_interrupt_handler:
    pushad
    push ds
    push es
    push fs
    push gs

    ; 发送EOI消息，否则下一次中断不发生
    mov al, 0x20
    out 0x20, al
    out 0xa0, al
    
    call c_time_interrupt_handler

    pop gs
    pop fs
    pop es
    pop ds
    popad
    iret
```

最后做一些简单的修改就可以调用进程了。

#### print

简单写个系统调用就可以了。

```asm
void syscall_print(const char*s)
{
    printf(s);
}

void first_process()
{
    asm_system_call(1,int("hello world\n"));
    asm_halt();
}
```

#### findProgramByPid

简单的利用线性查找即可

```cpp
PCB* ProgramManager::findProgramByPid(int pid)
{
	return (PCB*)((int)PCB_SET + pid * PAGE_SIZE);
}
```


## Assignment 2 Fork的奥秘

进入内核态后，fork的实现通过`ProgramManager::fork`来完成。

```cpp
int ProgramManager::fork()
{
    bool status = interruptManager.getInterruptStatus();
    interruptManager.disableInterrupt();

    // 禁止内核线程调用，因为内核线程并没有设置
    PCB *parent = this->running;
    if (!parent->pageDirectoryAddress)
    {
        interruptManager.setInterruptStatus(status);
        return -1;
    }

    // 创建子进程
    int pid = executeProcess("", 0);
    if (pid == -1)
    {
        interruptManager.setInterruptStatus(status);
        return -1;
    }

    // 初始化子进程
    PCB *child = ListItem2PCB(this->allPrograms.back(), tagInAllList);
    bool flag = copyProcess(parent, child); // 复制父进程的资源到子进程中。

    if (!flag)
    {
        child->status = ProgramStatus::DEAD;
        interruptManager.setInterruptStatus(status);
        return -1;
    }

    interruptManager.setInterruptStatus(status);
    return pid;
}
```



#### 资源的复制

1. 复制父进程的0特权级栈到子进程中。为此，需要找到父进程的0特权级栈的地址。

   当我们调用fork系统调用后，我们会从用户态进入内核态。

   需要复制的父进程0特权栈的起始地址只是进程的PCB所在的页的顶部减去一个`ProgramStartStack`的大小，长度便是一个`ProgramStartStack`的大小。这就是`copyProcess`开头的语句。我们实际上就是把在中断的那一刻保存的寄存器的内容复制到子进程的0特权级栈中。

   ```cpp
       // 复制进程0级栈
       ProcessStartStack *childpss =
           (ProcessStartStack *)((int)child + PAGE_SIZE - sizeof(ProcessStartStack));
       ProcessStartStack *parentpss =
           (ProcessStartStack *)((int)parent + PAGE_SIZE - sizeof(ProcessStartStack));
       memcpy(parentpss, childpss, sizeof(ProcessStartStack));
       // 设置子进程的返回值为0
       childpps->eax = 0;
   ```

   ​

2. 初始化子进程的0特权级栈。

   ```cpp
       // 准备执行asm_switch_thread的栈的内容
       child->stack = (int *)childpss - 7;
       child->stack[0] = 0;
       child->stack[1] = 0;
       child->stack[2] = 0;
       child->stack[3] = 0;
       child->stack[4] = (int)asm_start_process;
       child->stack[5] = 0;             // asm_start_process 返回地址
       child->stack[6] = (int)childpss; // asm_start_process 参数
   ```

   这样做是为了和`asm_switch_thread`的过程对应起来。当子进程被调度执行时，子进程能够从`asm_switch_thread`跳转到`asm_start_proces`处执行。

   ​

3. 设置子进程的PCB、复制父进程的管理虚拟地址池的bitmap到子进程的管理虚拟地址池的bitmap。

   ```cpp
       // 设置子进程的PCB
       child->status = ProgramStatus::READY;
       child->parentPid = parent->pid;
       child->priority = parent->priority;
       child->ticks = parent->ticks;
       child->ticksPassedBy = parent->ticksPassedBy;
       strcpy(parent->name, child->name);

       // 复制用户虚拟地址池
       int bitmapLength = parent->userVirtual.resources.length;
       int bitmapBytes = ceil(bitmapLength, 8);
       memcpy(parent->userVirtual.resources.bitmap, child->userVirtual.resources.bitmap, bitmapBytes);
   ```

   然后，我们从内核中分配一页来作为数据复制的中转页。

   ```cpp
       // 从内核中分配一页作为中转页
       char *buffer = (char *)memoryManager.allocatePages(AddressPoolType::KERNEL, 1);
       if (!buffer)
       {
           child->status = ProgramStatus::DEAD;
           return false;
       }
   ```

   分页机制实现了地址隔离，父进程就无法将数据复制到具有相同虚拟地址的子进程中。因此，我们需要借助于内核空间的中转页。我们首先在父进程的虚拟地址空间下将数据复制到中转页中，再切换到子进程的虚拟地址空间中，然后将中转页复制到子进程对应的位置。



4. 将父进程的页目录表复制到子进程中。

   ```cpp
       // 子进程页目录表物理地址
       int childPageDirPaddr = memoryManager.vaddr2paddr(child->pageDirectoryAddress);
       // 父进程页目录表物理地址
       int parentPageDirPaddr = memoryManager.vaddr2paddr(parent->pageDirectoryAddress);
       // 子进程页目录表指针(虚拟地址)
       int *childPageDir = (int *)child->pageDirectoryAddress;
       // 父进程页目录表指针(虚拟地址)
       int *parentPageDir = (int *)parent->pageDirectoryAddress;

       // 子进程页目录表初始化
       memset((void *)child->pageDirectoryAddress, 0, 768 * 4);

       // 复制页目录表
       for (int i = 0; i < 768; ++i)
       {
           // 无对应页表
           if (!(parentPageDir[i] & 0x1))
           {
               continue;
           }

           // 从用户物理地址池中分配一页，作为子进程的页目录项指向的页表
           int paddr = memoryManager.allocatePhysicalPages(AddressPoolType::USER, 1);
           if (!paddr)
           {
               child->status = ProgramStatus::DEAD;
               return false;
           }
           // 页目录项
           int pde = parentPageDir[i];
           // 构造页表的起始虚拟地址
           int *pageTableVaddr = (int *)(0xffc00000 + (i << 12));

           asm_update_cr3(childPageDirPaddr); // 进入子进程虚拟地址空间

           childPageDir[i] = (pde & 0x00000fff) | paddr; // 设置子进程页目录表的页目录项
           memset(pageTableVaddr, 0, PAGE_SIZE); // 初始化页目录项指向的页表

           asm_update_cr3(parentPageDirPaddr); // 回到父进程虚拟地址空间
       }
   ```

   ​



5. 复制页表和物理页的数据。

   ```cpp
       // 复制页表和物理页
       for (int i = 0; i < 768; ++i)
       {
           // 无对应页表
           if (!(parentPageDir[i] & 0x1))
           {
               continue;
           }

           // 计算页表的虚拟地址
           int *pageTableVaddr = (int *)(0xffc00000 + (i << 12));

           // 复制物理页
           for (int j = 0; j < 1024; ++j)
           {
               // 无对应物理页
               if (!(pageTableVaddr[j] & 0x1))
               {
                   continue;
               }

               // 从用户物理地址池中分配一页，作为子进程的页表项指向的物理页
               int paddr = memoryManager.allocatePhysicalPages(AddressPoolType::USER, 1);
               if (!paddr)
               {
                   child->status = ProgramStatus::DEAD;
                   return false;
               }

               // 构造物理页的起始虚拟地址
               void *pageVaddr = (void *)((i << 22) + (j << 12));
               // 页表项
               int pte = pageTableVaddr[j];
               // 复制出父进程物理页的内容到中转页
               memcpy(pageVaddr, buffer, PAGE_SIZE);

               asm_update_cr3(childPageDirPaddr); // 进入子进程虚拟地址空间

               pageTableVaddr[j] = (pte & 0x00000fff) | paddr;
               // 从中转页中复制到子进程的物理页
               memcpy(buffer, pageVaddr, PAGE_SIZE);

               asm_update_cr3(parentPageDirPaddr); // 回到父进程虚拟地址空间
           }
       }
   ```

   ​

到这里，fork的核心框架便实现了。





## Assignment 3 哼哈二将 wait & exit

#### exit

总的来看，exit的实现主要分为三步。

1. 标记PCB状态为`DEAD`并放入返回值。

   ```cpp
    // 第一步，标记PCB状态为`DEAD`并放入返回值。
       PCB *program = this->running;
       program->retValue = ret;
       program->status = ProgramStatus::DEAD;
   ```

2. 如果PCB标识的是进程，则释放进程所占用的物理页、页表、页目录表和虚拟地址池bitmap的空间。否则不做处理。

   ```cpp
   // 第二步，如果PCB标识的是进程，则释放进程所占用的物理页、页表、页目录表和虚拟地址池bitmap的空间。
       if (program->pageDirectoryAddress)
       {
           pageDir = (int *)program->pageDirectoryAddress;
           for (int i = 0; i < 768; ++i)
           {
               if (!(pageDir[i] & 0x1))
               {
                   continue;
               }

               page = (int *)(0xffc00000 + (i << 12));

               for (int j = 0; j < 1024; ++j)
               {
                   if(!(page[j] & 0x1)) {
                       continue;
                   }

                   paddr = memoryManager.vaddr2paddr((i << 22) + (j << 12));
                   memoryManager.releasePhysicalPages(AddressPoolType::USER, paddr, 1);
               }

               paddr = memoryManager.vaddr2paddr((int)page);
               memoryManager.releasePhysicalPages(AddressPoolType::USER, paddr, 1);
           }

           memoryManager.releasePages(AddressPoolType::KERNEL, (int)pageDir, 1);
           
           int bitmapBytes = ceil(program->userVirtual.resources.length, 8);
           int bitmapPages = ceil(bitmapBytes, PAGE_SIZE);

           memoryManager.releasePages(AddressPoolType::KERNEL,
                                      (int)program->userVirtual.resources.bitmap, 
                                      bitmapPages);

       }
   ```

3. 立即执行线程/进程调度。

   ```cpp
   // 第三步，立即执行线程/进程调度。
       schedule();
   ```

#### wait

wait的参数`retval`用来存放子进程的返回值，如果`retval==nullptr`，则说明父进程不关心子进程的返回值。wait的返回值是被回收的子进程的pid。如果没有子进程，则wait返回`-1`。在父进程调用了wait后，如果存在子进程但子进程的状态不是`DEAD`，则父进程会被阻塞，即wait不会返回直到子进程结束。

wait的实现实际上是由`ProgramManager`来完成的。

```cpp
int ProgramManager::wait(int *retval)
{
    PCB *child;
    ListItem *item;
    bool interrupt, flag;

    while (true)
    {
        interrupt = interruptManager.getInterruptStatus();
        interruptManager.disableInterrupt();

        item = this->allPrograms.head.next;

        // 查找子进程，找到一个状态为DEAD的子进程
        flag = true;
        while (item)
        {
            child = ListItem2PCB(item, tagInAllList);
            if (child->parentPid == this->running->pid)
            {
                flag = false;
                if (child->status == ProgramStatus::DEAD)
                {
                    break;
                }
            }
            item = item->next;
        }

        if (item) // 找到一个可返回的子进程
        {
            if (retval) // 不为nullptr
            {
                *retval = child->retValue;
            }

            int pid = child->pid;
            releasePCB(child);
            interruptManager.setInterruptStatus(interrupt);
            return pid;
        }
        else 
        {
            if (flag) // 子进程已经返回
            {
                
                interruptManager.setInterruptStatus(interrupt);
                return -1; // 没有找到子进程，返回-1
            }
            else // 存在子进程，但子进程的状态不是DEAD
            {
                interruptManager.setInterruptStatus(interrupt);
                schedule();
            }
        }
    }
}
```

最后存在子进程但子进程的状态不是`DEAD`，因此我们执行调度。注意到该进程的主体是一个死循环，因此当进程的第53语句返回后，wait并不会返回。而是再一次重复上面的步骤，尝试回收子进程。也就是前面所说的，当父进程调用wait后，如果存在子进程但子进程的状态不是`DEAD`，则父进程会被阻塞，即wait不会返回直到子进程结束。



## 实验过程



## Assignment 1 系统调用

编写一个系统调用，然后在进程中调用之，根据结果回答以下问题。

- 展现系统调用执行结果的正确性，结果截图并并说说你的实现思路。

  ![ass1-1](images/ass1-1.png)

- 请根据gdb来分析执行系统调用后的栈的变化情况。

  ![ass1-2](images/ass1-2.png)

  ​

  ![ass1-3](images/ass1-3.png)

  传入的参数分别为1,10, 2, 3, 4，根据上面两张图可以看出，eax本身一直为1，没有变化，而根据寻参规则，ebx，ecx,edx,esi,edx分别为10，2，3，4，0（未传参，值为默认参数0），ebp，esp也随之发生变化

- 请根据gdb来说明TSS在系统调用执行过程中的作用。

  ![ass1-4](images/ass1-4.png)

  ​

  在调用`0x80`中断之前处于用户态，根据GDB调试可知 `ss=0x3b` ，`esp=0x8048fb8` ,`cs=0x2b`。

  ​

  ![ass1-5](images/ass1-5.png)

  ​

  在调用`0x80`中断之后处于内核态，根据GDB调试可知 `ss=0x10` ，`esp=0xc0025808` ,`cs=0x20`，

  ` CODE_SELECTOR 0x20，STACK_SELECTOR 0x10`，可以看出用户态转入到了内核态，堆栈也切换到了0特权级栈。TSS的作用便是在从低特权级向高特权级转变的过程中提供0特权级栈所在段选择子和段内偏移，TSS在进程切换时起着重要的作用，通过它保存CPU中各寄存器的值，实现进程的挂起和恢复。

  ​

  ![ass1-6](images/ass1-6.png)

返回中断后，我们可以看见现在已经处于用户态，根据GDB调试可知 `ss=0x3b` ，`esp=0x8048fb8` ,`cs=0x2b`，已经恢复原来的寄存器值



#### `printf 验证`

![ass-p](images/ass-p.png)

## Assignment 2 Fork的奥秘

- 请根据代码逻辑和执行结果来分析fork实现的基本思路。

  已经在实验方案中详细叙述。运行结果如下：

  ![ass2-1](images/ass2-1.png)



- 父进程的执行流程

  ![ass2-2](images/ass2-2.png)

  进入中断前的寄存器/栈值

  ![ass2-3](images/ass2-3.png)

  发生中断

  ![ass2-4](images/ass2-4.png)

  还原中断发生之前父进程通用寄存器的值

  ![ass2-5](images/ass2-5.png)

  最后可以看到父进程返回 `pid=2`

- 子进程的执行流程

  首先区别于父进程，子进程由 `asm_start_process` 进入

  数据寄存器和段寄存器变化

  ![ass2-6](images/ass2-6.jpg)

  根据目前的cs,ss,esp值，也可以看出目前操作系统处于内核态，eax,esp已经被初始化

  ​

  ![ass2-7](images/ass2-7.png)

  看看即将`iret` 前的寄存器/栈值，已经成功将父进程栈指针的值赋给子进程的，可以看到操作系统应当仍处于内核态，但是ss，cs值已经改变了

  ![ass2-8](images/ass2-8.png)

  此时中断返回，内核态转用户态

  ![ass2-9](images/ass2-9.png)

  恢复父进程的5个寄存器值，返回调用fork（）处

  ![ass2-10](images/ass2-10.png)

  到这里已经可以看到子进程返回 `pid = 0`

  父进程子进程的不同之处在于子进程会通过栈上保存的返回地址为asm_start_process来进入进程，其它总体过程我们可以看到基本是一致的，

- 请根据代码逻辑和gdb来解释fork是如何保证子进程的`fork`返回值是0，而父进程的`fork`返回值是子进程的pid。

  ```cpp
  "
  """"""
  "
      // 设置子进程的返回值为0
      childpps->eax = 0;
  ```

  设置eax这一部分的内容就是我们fork返回值不同的关键，函数的返回值是通过`eax`寄存器来保存，在子进程复制父进程资源后，eax的值如上代码，被修改为0，而后其值一直未被改变，所以最后返回值为0。如下：

  ![ass2-11](images/ass2-11.png)

  对于父进程的返回值，其实上面父进程的过程中，已经有答案了，在 `int 80` 中断前后，我们可以看到eax的值均为2，asm_system_call调用了syscall_fork()，syscall_fork()调用了programManager::fork()，而programManager::fork()如下直接返回 pid 的值，即为eax=2。

  ```cpp
  "
  """"""
  "
  // 返回进程的pid    
  return pid;
  ```



## Assignment 3 哼哈二将 wait & exit

- 请结合代码逻辑和具体的实例来分析exit的执行过程。

  见实验方案，运行结果如下：

  ![ass3-1](images/ass3-1.png)

  ​

- 请分析进程退出后能够隐式地调用exit和此时的exit返回值是0的原因。

  我们先回忆一下添加了exit的load_process

  ```cpp
  void load_process(const char *filename)
  {
  	...

      interruptStack->esp = memoryManager.allocatePages(AddressPoolType::USER, 1);
      if (interruptStack->esp == 0)
      {
          printf("can not build process!\n");
          process->status = ProgramStatus::DEAD;
          asm_halt();
      }
      interruptStack->esp += PAGE_SIZE;
      
      // 设置进程返回地址
      int *userStack = (int *)interruptStack->esp;
      userStack -= 3;
      userStack[0] = (int)exit;
      userStack[1] = 0;
      userStack[2] = 0;

      interruptStack->esp = (int)userStack;

  	...
  }
  ```

  `void exit(int ret)`函数的起始地址以及参数`ret`的值放置在堆栈中，栈顶是返回地址 `userStack[0] = (int)exit`，如果一个进程结束，就会从栈中找到返回地址，放入`eip`，所以这样进程就可以隐式跳转到`void exit(int ret)`。而`userStack[1]`是exit的返回地址，`userStack[2]`是exit的参数ret。故返回值为0。

  ​

  根据上述所说，创建一个空进程，执行后隐式调用了exit

  ![ass-3-2](images/ass-3-2.png)

  如下图，可以看见返回值是0。

  ![ass3-3](images/ass3-3.png)

  ​

- 请结合代码逻辑和具体的实例来分析wait的执行过程。

  见实验方案，运行结果如下：

  ![ass3-4](images/ass3-4.png)

  ​

- 如果一个父进程先于子进程退出，那么子进程在退出之前会被称为孤儿进程。子进程在退出后，从状态被标记为`DEAD`开始到被回收，子进程会被称为僵尸进程。请对代码做出修改，实现回收僵尸进程的有效方法。

  参考一下资料，有父进程回收法以及init进程回收法两种方法

  [处理僵尸进程的两种经典方法 - 穆晨 - 博客园](https://www.cnblogs.com/muchen/p/6354573.html)

  #### 父进程回收法

  wait函数将使其调用者阻塞，直到其某个子进程终止。故父进程可调用wait函数回收其僵尸子进程。这个修改也很简单，如下：

  ```cpp
  void first_process()
  {
      int pid = fork();
      if (pid) // 父进程
      {
          asm_system_call(0, programManager.running->pid, 1);
          int pi = wait(nullptr); 
          printf("father process exit\n");
      }
      else
      {
          asm_system_call(0, programManager.running->pid, 0);
          printf("child process exit\n");
          exit(0);
      }
  }
  ```

  实验结果如下，符合预期，父进程没有提前退出，等待了子进程回收，父进程再回收。

  ![ass3-5-1](images/ass3-5-1.png)

  ​

  #### init进程回收法

  父进程回收法需要父进程去等待子进程，但在很多情况下，这并不合适，因为父进程也许还有其他任务要做，不能阻塞在这里。在讲述下面这种不用父进程等待就能完成回收子进程的方法之前，先请明白以下两个概念：

  ​       1. 如果父进程先于子进程结束，那么子进程的父进程自动改为 init 进程。

  ​       2. 如果 init 的子进程结束，则 init 进程会自动回收其子进程的资源而不是让它变成僵尸进程。

  最先创建一个init进程

  ```cpp
  void init(void *arg)
  {
      printf("start process\n");
      programManager.executeProcess((const char *)first_process, 1);    
      while (1)
      {
          int pid = wait(nullptr);
          printf("test process pid: %d\n", pid);
      }   
  }
  ```

  修改一下exit函数，在后面添加以下内容，其实就是实现上述两步。

  ```cpp
      PCB *child;
      ListItem *item = this->allPrograms.head.next;
      while (item)
      {
          child = ListItem2PCB(item, tagInAllList);
          // 找到子进程
          if (child->parentPid == this->running->pid)
          {
          	// 修改子进程的父亲
              child->parentPid = this->running->parentPid;
          }
          item = item->next;
      }
  ```

  实验结果如下，符合预期

  ![ass3-6](images/ass3-6.png)




## 实验总结

在本次实验中，又是一个全新的挑战。首先简单学习了保护模式下的特权级的相关内容。学习如何通过特权级保护，区分内核态和用户态，从而限制用户态的代码对特权指令的使用或对资源的访问等。其次学习了系统调用，系统调用通过三步来创建进程。这里，首先回顾了上次实验的分页机制等知识，在这些基础上修改，实现进程之间的虚拟地址空间的隔离。最后学习了fork/wait/exit的一种简洁的实现思路。

这次的实验更多偏向了理解，自己写代码部分变少了，更多是利用GDB去探查栈和寄存器变化，更好的去理解fork/wait/exit函数的实现原理与实现过程。这次实验，教程还给我们提了很多问题，需要我们自己理解教程后去解决问题。面对一些陌生的代码，直接想解决问题是不可能的，必须反复看教程，结合理论课所学，才能更好的去回答问题，不那么理解的地方可以通过上网查，和同学讨论来解决。我认为fork的关键在于资源的复制，做好这一点，其它边边角角的修改就不难操作了，然后要理解父进程与子进程执行完fork后的返回过程的异同。而exit 的要点在于理解它的执行过程，为什么能隐式调用exit并且返回0值。wait函数可以阻塞，理解它的实现过程后，我们可以用它帮助实现孤儿进程（僵尸进程）问题的解决，一个方案是父进程回收法，另一个是init进程回收法（我写了这两个）。

通过这次实验，也是收获了很多东西。



## 参考文献

https://gitee.com/code_sysu/os2021-lab8

[处理僵尸进程的两种经典方法 - 穆晨 - 博客园](https://www.cnblogs.com/muchen/p/6354573.html)