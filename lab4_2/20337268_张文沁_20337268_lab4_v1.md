![img](file:///C:\Users\张文沁\AppData\Local\Temp\ksohtml\wps1965.tmp.jpg)

 

 

# 						本科生实验报告



## 实验课程:	操作系统实验

## 实验名称:	第三章：中断

## 专业名称:	信息与计算科学

## 学生姓名:	张文沁

## 学生学号:	20337268

## 实验地点:	

## 实验成绩:	

## 报告时间:	2022.4.2

> ##### 大纲：
>
> 1. ##### 实验要求
>
> 2. ##### 实验过程
>
> 3. ##### 关键代码
>
> 4. ##### 实验结果
>
> 5. ##### 问题总结



# **1.** ***实验要求***

 实验要求

> + DDL：2021年4月15号 23:59
> + 提交的内容：将**4个assignment的代码**和**实验报告**放到**压缩包**中，命名为“**lab4-姓名-学号**”，并交到课程网站上[http://course.dds-sysu.tech/course/3/homework]
> + **材料的Example的代码放置在`src`目录下**。

1. 实验不限语言， C/C++/Rust都可以。
2. 实验不限平台， Windows、Linux和MacOS等都可以。
3. 实验不限CPU， ARM/Intel/Risc-V都可以。

# **2.** ***实验过程***

## 	Assignment1：

> ###### 		复现Example 1，结合具体的代码说明C代码调用汇编函数的语法和汇编代码调用C函数的语法。例如，结合代码说明`global`、`extern`关键字的作用，为什么C++的函数前需要加上`extern "C"`等， 结果截图并说说你是怎么做的。同时，学习make的使用，并用make来构建Example 1，结果截图并说说你是怎么做的。 
>

#### 	1. 制作Makefile

代码参见 `3.关键代码`

#### 	2. 执行Makefile



#### 	1. global关键字的作用：声明该函数为全局函数，因为在main.cpp中直接引用了function_from_asm(),如果不在asm_func.asm中定义其为global，则无法在main.cpp中调用

![image-20220410213317883](C:\Users\张文沁\AppData\Roaming\Typora\typora-user-images\image-20220410213317883.png)

#### 	2. `extern`关键字的作用：

##### 		基本解释：`extern`可以置于变量或函数前，以标识变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找定义，实质上是一种函数或变量声明。

#### 	3. `extern "C"`的作用：

##### 		当 `extern` 与"C"一起连用时，如: `extern "C" void fun(int a, int b)`,则告诉编译器在编译fun该函数名时按着C的规则去编译相应的函数名而非按照C++，C++的规则在翻译这个函数名时会把fun这个名字变得面目全非,因为C++为了解决函数的多态问题，会将函数名和参数联合在一起生成一份中间的函数名，而C语言不会，于是在C++和C进行连接的时候（如该代码所示）C会找不到对应发函数，此时就需要使用extern "C"来进行连接指定，意思是告诉编译器不要生成中间函数名。

![img](file:///C:\Users\张文沁\AppData\Local\Temp\ksohtml\wps8AD3.tmp.jpg)

## 	Assignment2:

> ###### 复现Example 2，在进入`setup_kernel`函数后，将输出 Hello World 改为输出你的学号，结果截图并说说你是怎么做的。
>

##### 	结果见 `4.实验结果` 部分

##### 	过程：对照实验指导进行代码修改和调试

## 	Assignment3:

> ###### 复现Example 3，你可以更改Example中默认的中断处理函数为你编写的函数，然后触发之，结果截图并说说你是怎么做的。

##### 仍然是参照实验指导解读代码和自我尝试

```asm
ASM_UNHANDLED_INTERRUPT_INFO db 'My interrupt function...'
                             db 0
ASM_IDTR dw 0
         dd 0

asm_unhandled_interrupt: ;以关中断为开始
    cli
    mov esi, ASM_UNHANDLED_INTERRUPT_INFO ;标识字符串
    xor ebx, ebx ;清零
    mov ah, 0x03 ;起点
.output_information: ;输出标识字符串
    cmp byte[esi], 0 ;字符串为空则结束
    je .end 
    mov al, byte[esi] 
    mov word[gs:bx], ax ;输出字符串
    inc esi
    add ebx, 2 ;到下一个字符
    jmp .output_information
.end:
    jmp $
```

![image-20220411154758624](C:\Users\张文沁\AppData\Roaming\Typora\typora-user-images\image-20220411154758624.png)

## 	Assignment4:

> ###### 复现Example 4，仿照Example中使用C语言来实现时钟中断的例子，利用C/C++、 InterruptManager、STDIO和你自己封装的类来实现你的时钟中断处理过程，结果截图并说说你是怎么做的。注意，不可以使用纯汇编的方式来实现。(例如，通过时钟中断，你可以在屏幕的第一行实现一个跑马灯。跑马灯显示自己学号和英文名，即类似于LED屏幕显示的效果。)

##### 	参照实验指导解读代码和自我尝试，实现样例和需要的学号屏闪显示

# **3.** ***关键代码***

## 	Assignment1：

> ### 	Makefile如下：中间三条指令可以进行合并，为后面的代码，但是因为asm文件和c,cpp文件糅杂，并未进行尝试
>

```asm
.PHONY:clean

main.out : asm_func.o c_func.o cpp_func.o main.o
	g++ -o main.out main.o c_func.o cpp_func.o asm_func.o -m32
c_func.o : c_func.c
	gcc -o c_func.o -m32 -c c_func.c
cpp_func.o : cpp_func.cpp
	g++ -o cpp_func.o -m32 -c cpp_func.cpp
main.o : main.cpp
	g++ -o main.o -m32 -c main.cpp
asm_func.o : asm_func.asm
	nasm -o asm_func.o -f elf32 asm_func.asm

clean:
	rm -rf *.o
```

```asm
.PHONY:clean
FM = c_func.o cpp_func.o main.o
%.c : %.o
    gcc -o -$ < -c $@
asm_func.o : asm_func.asm
	nasm -o asm_func.o -f elf32 asm_func.asm
clean:
	rm -rf *.o
```

## 	Assignment2:

> ##### 与所给代码并无太大差异，区别在于要输出的字符串的改变

## 	Assignment3: 

> ##### 修改后的中断处理函数如下：

```asm
ASM_UNHANDLED_INTERRUPT_INFO db 'My interrupt function...'
                             db 0
ASM_IDTR dw 0
         dd 0

asm_unhandled_interrupt: ;以关中断为开始
    cli
    mov esi, ASM_UNHANDLED_INTERRUPT_INFO ;标识字符串
    xor ebx, ebx ;清零
    mov ah, 0x03 ;起点
.output_information: ;输出标识字符串
    cmp byte[esi], 0 
    je .end ;为0即跳转到结束
    mov al, byte[esi] ;字符串的输出
    mov word[gs:bx], ax
    inc esi
    add ebx, 2 ;跳转到下一个字符
    jmp .output_information
.end:
    jmp $
```

## 	Assignment4: 

> ##### 一个中断处理函数：对中断处理函数进行修改即可实现所需的功能

```c
// 中断处理函数
extern "C" void c_time_interrupt_handler()
{
    // 清空屏幕
    for (int i = 0; i < 80; ++i)
    {
        stdio.print(0, i, ' ', 0x07);
    }

    // 输出学号
    ++times;
    char str[] = "My number:";
    char number[11] = {'2','0','3','3','7','2','6','8','Z','W','Q'};
    int temp = times%12;
    
	for (int i = 0;i < temp;++i){
		stdio.moveCursor(0);
	    for(int i = 0; str[i]; ++i ) {
		stdio.print(str[i]);
	    }
		for(int j = 0;j < temp;++j){
			stdio.print(number[j]);
		}

	}
}
```

## ***实验结果***

## 	Assignment1：

![img](file:///C:\Users\张文沁\AppData\Local\Temp\ksohtml\wps4B55.tmp.jpg)

### 下面为make下执行结果

## ![img](file:///C:\Users\张文沁\AppData\Local\Temp\ksohtml\wps39AD.tmp.jpg)

## 	Assignment2:

### 样例实验结果（命令编译实现）

![image-20220410233740435](C:\Users\张文沁\AppData\Roaming\Typora\typora-user-images\image-20220410233740435.png)

### 样例实验结果（makefile实现）：

![image-20220410233904804](C:\Users\张文沁\AppData\Roaming\Typora\typora-user-images\image-20220410233904804.png)

### 输出学号结果：

![image-20220410233918649](C:\Users\张文沁\AppData\Roaming\Typora\typora-user-images\image-20220410233918649.png)

### DEBUG过程：

#### 	启动gdb并设置断点:

![image-20220410234050004](C:\Users\张文沁\AppData\Roaming\Typora\typora-user-images\image-20220410234050004.png)

#### 	代码显示：![image-20220410234125233](C:\Users\张文沁\AppData\Roaming\Typora\typora-user-images\image-20220410234125233.png)

#### 读取fs寄存器：对照进程可知结果正确

![image-20220410234232203](C:\Users\张文沁\AppData\Roaming\Typora\typora-user-images\image-20220410234232203.png)

## 	Assignment3:

### 样例运行结果：

![image-20220410235757996](C:\Users\张文沁\AppData\Roaming\Typora\typora-user-images\image-20220410235757996.png)

### DEBUG中加载代码运行过程和中断描述符的查看：

![image-20220411000059236](C:\Users\张文沁\AppData\Roaming\Typora\typora-user-images\image-20220411000059236.png)

### 对照可知结果正确：

![image-20220411000108058](C:\Users\张文沁\AppData\Roaming\Typora\typora-user-images\image-20220411000108058.png)

### 修改中断处理函数之后的结果：

![image-20220411154816175](C:\Users\张文沁\AppData\Roaming\Typora\typora-user-images\image-20220411154816175.png)

## 	Assignment4:

### 样例实现：

![image-20220411162330636](C:\Users\张文沁\AppData\Roaming\Typora\typora-user-images\image-20220411162330636.png)

### 屏闪输出学号实现：

![image-20220411172440896](C:\Users\张文沁\AppData\Roaming\Typora\typora-user-images\image-20220411172440896.png)

![image-20220411172452727](C:\Users\张文沁\AppData\Roaming\Typora\typora-user-images\image-20220411172452727.png)

![image-20220411172500433](C:\Users\张文沁\AppData\Roaming\Typora\typora-user-images\image-20220411172500433.png)

### 视频显示：

#### 	见文件夹内容

## **5.** ***问题总结***

## 	Assignment1：

1. ###### i386 架构于输入文件 c_func.o 与 i386:x86-64 输出不兼容

   1. ###### 确定了ubuntu框架

   2. ###### 查询资料得知nasm 编译产生的是32位的目标代码，gcc 在64位平台上默认产生的是64位的目标代码，这两者在链接的时候出错，gcc在64位平台上默认以64位的方式链接。
   3. ###### 编译时参数缺少导致错误

   ###### 解决方案：让gcc 产生32位的代码，并在链接的时候以32位的方式进行链接

![image-20220330205535856](C:\Users\张文沁\AppData\Roaming\Typora\typora-user-images\image-20220330205535856.png)

## 	Assignment2:

## 	Assignment3:

1. ###### 在debug中，需要运行结束之后查看中断描述符，否则无法正确显示，错误结果如下：
   
   ![image-20220411000215728](C:\Users\张文沁\AppData\Roaming\Typora\typora-user-images\image-20220411000215728.png)

## 	Assignment4: